{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback, useRef, useMemo } from 'react';\nimport { checkQuickHealth } from '../api';\nimport useWebSocket from './useWebSocket';\nconst useHealthMonitoring = (options = {}) => {\n  _s();\n  const {\n    enableNotifications = true,\n    autoStart = true\n  } = options;\n  const [health, setHealth] = useState({\n    backend: 'unknown',\n    database: 'unknown',\n    websocket: 'unknown',\n    honeypotManager: 'unknown'\n  });\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [lastCheck, setLastCheck] = useState(null);\n  const [error, setError] = useState(null);\n  const [uptime, setUptime] = useState(null);\n  const [metrics, setMetrics] = useState({\n    totalEvents: 0,\n    activeConnections: 0,\n    errorRate: 0,\n    honeypots: []\n  });\n  const [serviceDetails, setServiceDetails] = useState({});\n\n  // Use WebSocket for real-time health updates\n  const {\n    isConnected,\n    healthStatus,\n    subscribeToHealth,\n    unsubscribeFromHealth\n  } = useWebSocket();\n\n  // Use refs to track previous state and avoid unnecessary updates\n  const previousHealthRef = useRef({});\n  const fallbackIntervalRef = useRef(null);\n  const lastLogTime = useRef(0);\n  const hasReceivedWebSocketUpdate = useRef(false);\n  const lastErrorTime = useRef({}); // New ref for error logging circuit breaker\n\n  // Compute overall system health\n  const systemHealth = useMemo(() => {\n    const statuses = Object.values(health);\n    if (statuses.includes('error') || statuses.includes('stopped')) {\n      return 'error';\n    }\n    if (statuses.includes('unhealthy') || statuses.includes('degraded') || statuses.includes('disconnected')) {\n      return 'unhealthy';\n    }\n    if (statuses.every(status => status === 'healthy' || status === 'running' || status === 'connected' || status === 'active')) {\n      return 'healthy';\n    }\n    return 'unknown';\n  }, [health]);\n\n  // Smart logging - only log significant changes\n  const shouldLog = useCallback((message, isHealthy = true) => {\n    const now = Date.now();\n    const tenMinutes = 10 * 60 * 1000; // Increased from 5 to 10 minutes\n\n    if (!isHealthy) {\n      return true; // Always log problems\n    }\n    if (now - lastLogTime.current > tenMinutes) {\n      lastLogTime.current = now;\n      return true;\n    }\n    return false;\n  }, []);\n\n  // Get health summary\n  const getHealthSummary = useCallback(() => {\n    const services = Object.values(health);\n    const healthyServices = services.filter(status => status === 'healthy' || status === 'running' || status === 'connected' || status === 'active').length;\n    return {\n      services: services.length,\n      healthy: healthyServices,\n      unhealthy: services.length - healthyServices,\n      uptime: uptime || 0\n    };\n  }, [health, uptime]);\n\n  // Get service status with details\n  const getServiceStatus = useCallback(serviceName => {\n    const status = health[serviceName] || 'unknown';\n    const details = serviceDetails[serviceName] || {};\n    return {\n      status,\n      lastChecked: details.lastChecked || (lastCheck ? lastCheck.toLocaleTimeString() : 'Never'),\n      responseTime: details.responseTime,\n      error: details.error,\n      details\n    };\n  }, [health, serviceDetails, lastCheck]);\n\n  // Format uptime in readable format\n  const formatUptime = useCallback(uptimeMs => {\n    if (!uptimeMs || uptimeMs < 0) return 'Unknown';\n    const seconds = Math.floor(uptimeMs / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    if (days > 0) {\n      return `${days}d ${hours % 24}h ${minutes % 60}m`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }, []);\n\n  // Process health status (from WebSocket or API)\n  const processHealthStatus = useCallback(healthData => {\n    var _healthData$services, _healthData$services$, _healthData$services2, _healthData$services3, _healthData$services4, _healthData$services5, _healthData$services6, _healthData$services7;\n    if (!healthData) return;\n    const newHealth = {\n      backend: ((_healthData$services = healthData.services) === null || _healthData$services === void 0 ? void 0 : (_healthData$services$ = _healthData$services.backend) === null || _healthData$services$ === void 0 ? void 0 : _healthData$services$.status) || 'unknown',\n      database: ((_healthData$services2 = healthData.services) === null || _healthData$services2 === void 0 ? void 0 : (_healthData$services3 = _healthData$services2.database) === null || _healthData$services3 === void 0 ? void 0 : _healthData$services3.status) || 'unknown',\n      websocket: ((_healthData$services4 = healthData.services) === null || _healthData$services4 === void 0 ? void 0 : (_healthData$services5 = _healthData$services4.websocket) === null || _healthData$services5 === void 0 ? void 0 : _healthData$services5.status) || 'unknown',\n      honeypotManager: ((_healthData$services6 = healthData.services) === null || _healthData$services6 === void 0 ? void 0 : (_healthData$services7 = _healthData$services6.honeypotManager) === null || _healthData$services7 === void 0 ? void 0 : _healthData$services7.status) || 'unknown'\n    };\n\n    // Only update if something actually changed\n    const hasChanges = Object.keys(newHealth).some(service => previousHealthRef.current[service] !== newHealth[service]);\n    if (hasChanges || !previousHealthRef.current.backend) {\n      var _healthData$metrics, _healthData$services8, _healthData$services9, _healthData$metrics2, _healthData$services0, _healthData$services1, _healthData$services10, _healthData$services11;\n      previousHealthRef.current = {\n        ...newHealth\n      };\n      setHealth(newHealth);\n      setLastCheck(new Date());\n      setError(null);\n\n      // Smart logging - only log real changes\n      const unhealthyServices = Object.entries(newHealth).filter(([_, status]) => status === 'unhealthy' || status === 'error' || status === 'stopped').map(([service, _]) => service);\n      if (unhealthyServices.length > 0) {\n        if (shouldLog('Service issues', false)) {\n          console.warn('🚨 Service issues:', unhealthyServices);\n        }\n      } else {\n        // Removed frequent \"System healthy\" console.log to reduce spam\n        // Only log when there are actual changes, not every health update\n        if (hasChanges && shouldLog('System healthy', true)) {\n          console.log('✅ System status updated');\n        }\n      }\n\n      // Store response data efficiently\n      if (healthData.uptime) {\n        setUptime(healthData.uptime * 1000);\n      }\n      setMetrics({\n        totalEvents: ((_healthData$metrics = healthData.metrics) === null || _healthData$metrics === void 0 ? void 0 : _healthData$metrics.totalEvents) || 0,\n        activeConnections: ((_healthData$services8 = healthData.services) === null || _healthData$services8 === void 0 ? void 0 : (_healthData$services9 = _healthData$services8.websocket) === null || _healthData$services9 === void 0 ? void 0 : _healthData$services9.connections) || 0,\n        errorRate: ((_healthData$metrics2 = healthData.metrics) === null || _healthData$metrics2 === void 0 ? void 0 : _healthData$metrics2.errorRate) || 0,\n        honeypots: healthData.honeypots || []\n      });\n      setServiceDetails({\n        backend: ((_healthData$services0 = healthData.services) === null || _healthData$services0 === void 0 ? void 0 : _healthData$services0.backend) || {},\n        database: ((_healthData$services1 = healthData.services) === null || _healthData$services1 === void 0 ? void 0 : _healthData$services1.database) || {},\n        websocket: ((_healthData$services10 = healthData.services) === null || _healthData$services10 === void 0 ? void 0 : _healthData$services10.websocket) || {},\n        honeypotManager: ((_healthData$services11 = healthData.services) === null || _healthData$services11 === void 0 ? void 0 : _healthData$services11.honeypotManager) || {}\n      });\n    }\n  }, [shouldLog]);\n\n  // WebSocket health status updates\n  useEffect(() => {\n    if (healthStatus) {\n      hasReceivedWebSocketUpdate.current = true;\n      processHealthStatus(healthStatus);\n    }\n  }, [healthStatus, processHealthStatus]);\n\n  // Fallback API health check (only when needed)\n  const performFallbackHealthCheck = useCallback(async () => {\n    try {\n      const response = await checkQuickHealth();\n      processHealthStatus(response);\n      return response;\n    } catch (err) {\n      // Only log errors if we haven't seen this error recently\n      const now = Date.now();\n      const errorKey = err.message || 'Unknown error';\n      if (!lastErrorTime.current[errorKey] || now - lastErrorTime.current[errorKey] > 60000) {\n        // Only log same error once per minute\n        console.error('❌ Fallback health check failed:', err.message);\n        lastErrorTime.current[errorKey] = now;\n      }\n      setError(err.message || 'Health check failed');\n      if (!error) {\n        setHealth(prev => ({\n          ...prev,\n          backend: 'error'\n        }));\n      }\n      return null;\n    }\n  }, [error, processHealthStatus]);\n\n  // Start monitoring\n  const startMonitoring = useCallback(() => {\n    if (isMonitoring) return;\n    setIsMonitoring(true);\n\n    // Subscribe to WebSocket health updates\n    if (isConnected) {\n      subscribeToHealth();\n    }\n\n    // Initial health check\n    performFallbackHealthCheck();\n\n    // Setup fallback polling (much less frequent)\n    const scheduleNextFallbackCheck = () => {\n      if (fallbackIntervalRef.current) {\n        clearTimeout(fallbackIntervalRef.current);\n      }\n\n      // Only use fallback if no WebSocket updates received recently\n      const interval = hasReceivedWebSocketUpdate.current ? 15 * 60 * 1000 // 15 minutes when WebSocket working\n      : 5 * 60 * 1000; // 5 minutes when WebSocket not working\n\n      fallbackIntervalRef.current = setTimeout(() => {\n        // Reset WebSocket flag and check if we need fallback\n        hasReceivedWebSocketUpdate.current = false;\n        performFallbackHealthCheck().then(() => {\n          if (isMonitoring) {\n            scheduleNextFallbackCheck();\n          }\n        });\n      }, interval);\n    };\n    scheduleNextFallbackCheck();\n  }, [isMonitoring, isConnected, subscribeToHealth, performFallbackHealthCheck]);\n\n  // Stop monitoring\n  const stopMonitoring = useCallback(() => {\n    if (fallbackIntervalRef.current) {\n      clearTimeout(fallbackIntervalRef.current);\n      fallbackIntervalRef.current = null;\n    }\n    unsubscribeFromHealth();\n    setIsMonitoring(false);\n  }, [unsubscribeFromHealth]);\n\n  // Auto-start monitoring\n  useEffect(() => {\n    if (autoStart) {\n      startMonitoring();\n    }\n    return () => {\n      stopMonitoring();\n    };\n  }, [autoStart, startMonitoring, stopMonitoring]);\n\n  // Subscribe to WebSocket when connected\n  useEffect(() => {\n    if (isConnected && isMonitoring) {\n      subscribeToHealth();\n    }\n  }, [isConnected, isMonitoring]); // Removed subscribeToHealth dependency that was causing infinite loop\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (fallbackIntervalRef.current) {\n        clearTimeout(fallbackIntervalRef.current);\n      }\n    };\n  }, []);\n  return {\n    health,\n    systemHealth,\n    isMonitoring,\n    lastCheck,\n    error,\n    uptime,\n    metrics,\n    serviceDetails,\n    isConnected: isConnected,\n    getHealthSummary,\n    getServiceStatus,\n    formatUptime,\n    startMonitoring,\n    stopMonitoring,\n    performHealthCheck: performFallbackHealthCheck // Keep for manual refresh\n  };\n};\n_s(useHealthMonitoring, \"dS42vBOnBhRcSbzyk799Rjfp1K4=\", false, function () {\n  return [useWebSocket];\n});\nexport default useHealthMonitoring;","map":{"version":3,"names":["useEffect","useState","useCallback","useRef","useMemo","checkQuickHealth","useWebSocket","useHealthMonitoring","options","_s","enableNotifications","autoStart","health","setHealth","backend","database","websocket","honeypotManager","isMonitoring","setIsMonitoring","lastCheck","setLastCheck","error","setError","uptime","setUptime","metrics","setMetrics","totalEvents","activeConnections","errorRate","honeypots","serviceDetails","setServiceDetails","isConnected","healthStatus","subscribeToHealth","unsubscribeFromHealth","previousHealthRef","fallbackIntervalRef","lastLogTime","hasReceivedWebSocketUpdate","lastErrorTime","systemHealth","statuses","Object","values","includes","every","status","shouldLog","message","isHealthy","now","Date","tenMinutes","current","getHealthSummary","services","healthyServices","filter","length","healthy","unhealthy","getServiceStatus","serviceName","details","lastChecked","toLocaleTimeString","responseTime","formatUptime","uptimeMs","seconds","Math","floor","minutes","hours","days","processHealthStatus","healthData","_healthData$services","_healthData$services$","_healthData$services2","_healthData$services3","_healthData$services4","_healthData$services5","_healthData$services6","_healthData$services7","newHealth","hasChanges","keys","some","service","_healthData$metrics","_healthData$services8","_healthData$services9","_healthData$metrics2","_healthData$services0","_healthData$services1","_healthData$services10","_healthData$services11","unhealthyServices","entries","_","map","console","warn","log","connections","performFallbackHealthCheck","response","err","errorKey","prev","startMonitoring","scheduleNextFallbackCheck","clearTimeout","interval","setTimeout","then","stopMonitoring","performHealthCheck"],"sources":["/home/demon/distributed-architecture/central-infrastructure/frontend/src/hooks/useHealthMonitoring.js"],"sourcesContent":["import { useEffect, useState, useCallback, useRef, useMemo } from 'react';\nimport { checkQuickHealth } from '../api';\nimport useWebSocket from './useWebSocket';\n\nconst useHealthMonitoring = (options = {}) => {\n  const { \n    enableNotifications = true,\n    autoStart = true\n  } = options;\n\n  const [health, setHealth] = useState({\n    backend: 'unknown',\n    database: 'unknown',\n    websocket: 'unknown',\n    honeypotManager: 'unknown'\n  });\n\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [lastCheck, setLastCheck] = useState(null);\n  const [error, setError] = useState(null);\n  const [uptime, setUptime] = useState(null);\n  const [metrics, setMetrics] = useState({\n    totalEvents: 0,\n    activeConnections: 0,\n    errorRate: 0,\n    honeypots: []\n  });\n  const [serviceDetails, setServiceDetails] = useState({});\n  \n  // Use WebSocket for real-time health updates\n  const { \n    isConnected, \n    healthStatus, \n    subscribeToHealth, \n    unsubscribeFromHealth \n  } = useWebSocket();\n  \n  // Use refs to track previous state and avoid unnecessary updates\n  const previousHealthRef = useRef({});\n  const fallbackIntervalRef = useRef(null);\n  const lastLogTime = useRef(0);\n  const hasReceivedWebSocketUpdate = useRef(false);\n  const lastErrorTime = useRef({}); // New ref for error logging circuit breaker\n\n  // Compute overall system health\n  const systemHealth = useMemo(() => {\n    const statuses = Object.values(health);\n    if (statuses.includes('error') || statuses.includes('stopped')) {\n      return 'error';\n    }\n    if (statuses.includes('unhealthy') || statuses.includes('degraded') || statuses.includes('disconnected')) {\n      return 'unhealthy';\n    }\n    if (statuses.every(status => status === 'healthy' || status === 'running' || status === 'connected' || status === 'active')) {\n      return 'healthy';\n    }\n    return 'unknown';\n  }, [health]);\n\n  // Smart logging - only log significant changes\n  const shouldLog = useCallback((message, isHealthy = true) => {\n    const now = Date.now();\n    const tenMinutes = 10 * 60 * 1000; // Increased from 5 to 10 minutes\n    \n    if (!isHealthy) {\n      return true; // Always log problems\n    }\n    \n    if (now - lastLogTime.current > tenMinutes) {\n      lastLogTime.current = now;\n      return true;\n    }\n    \n    return false;\n  }, []);\n\n  // Get health summary\n  const getHealthSummary = useCallback(() => {\n    const services = Object.values(health);\n    const healthyServices = services.filter(status => \n      status === 'healthy' || status === 'running' || status === 'connected' || status === 'active'\n    ).length;\n    \n    return {\n      services: services.length,\n      healthy: healthyServices,\n      unhealthy: services.length - healthyServices,\n      uptime: uptime || 0\n    };\n  }, [health, uptime]);\n\n  // Get service status with details\n  const getServiceStatus = useCallback((serviceName) => {\n    const status = health[serviceName] || 'unknown';\n    const details = serviceDetails[serviceName] || {};\n    \n    return {\n      status,\n      lastChecked: details.lastChecked || (lastCheck ? lastCheck.toLocaleTimeString() : 'Never'),\n      responseTime: details.responseTime,\n      error: details.error,\n      details\n    };\n  }, [health, serviceDetails, lastCheck]);\n\n  // Format uptime in readable format\n  const formatUptime = useCallback((uptimeMs) => {\n    if (!uptimeMs || uptimeMs < 0) return 'Unknown';\n    \n    const seconds = Math.floor(uptimeMs / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) {\n      return `${days}d ${hours % 24}h ${minutes % 60}m`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }, []);\n\n  // Process health status (from WebSocket or API)\n  const processHealthStatus = useCallback((healthData) => {\n    if (!healthData) return;\n\n    const newHealth = {\n      backend: healthData.services?.backend?.status || 'unknown',\n      database: healthData.services?.database?.status || 'unknown',\n      websocket: healthData.services?.websocket?.status || 'unknown',\n      honeypotManager: healthData.services?.honeypotManager?.status || 'unknown'\n    };\n\n    // Only update if something actually changed\n    const hasChanges = Object.keys(newHealth).some(\n      service => previousHealthRef.current[service] !== newHealth[service]\n    );\n\n    if (hasChanges || !previousHealthRef.current.backend) {\n      previousHealthRef.current = { ...newHealth };\n      setHealth(newHealth);\n      setLastCheck(new Date());\n      setError(null);\n\n      // Smart logging - only log real changes\n      const unhealthyServices = Object.entries(newHealth)\n        .filter(([_, status]) => status === 'unhealthy' || status === 'error' || status === 'stopped')\n        .map(([service, _]) => service);\n\n      if (unhealthyServices.length > 0) {\n        if (shouldLog('Service issues', false)) {\n          console.warn('🚨 Service issues:', unhealthyServices);\n        }\n      } else {\n        // Removed frequent \"System healthy\" console.log to reduce spam\n        // Only log when there are actual changes, not every health update\n        if (hasChanges && shouldLog('System healthy', true)) {\n          console.log('✅ System status updated');\n        }\n      }\n\n      // Store response data efficiently\n      if (healthData.uptime) {\n        setUptime(healthData.uptime * 1000);\n      }\n\n      setMetrics({\n        totalEvents: healthData.metrics?.totalEvents || 0,\n        activeConnections: healthData.services?.websocket?.connections || 0,\n        errorRate: healthData.metrics?.errorRate || 0,\n        honeypots: healthData.honeypots || []\n      });\n\n      setServiceDetails({\n        backend: healthData.services?.backend || {},\n        database: healthData.services?.database || {},\n        websocket: healthData.services?.websocket || {},\n        honeypotManager: healthData.services?.honeypotManager || {}\n      });\n    }\n  }, [shouldLog]);\n\n  // WebSocket health status updates\n  useEffect(() => {\n    if (healthStatus) {\n      hasReceivedWebSocketUpdate.current = true;\n      processHealthStatus(healthStatus);\n    }\n  }, [healthStatus, processHealthStatus]);\n\n  // Fallback API health check (only when needed)\n  const performFallbackHealthCheck = useCallback(async () => {\n    try {\n      const response = await checkQuickHealth();\n      processHealthStatus(response);\n      return response;\n    } catch (err) {\n      // Only log errors if we haven't seen this error recently\n      const now = Date.now();\n      const errorKey = err.message || 'Unknown error';\n      \n      if (!lastErrorTime.current[errorKey] || \n          (now - lastErrorTime.current[errorKey]) > 60000) { // Only log same error once per minute\n        console.error('❌ Fallback health check failed:', err.message);\n        lastErrorTime.current[errorKey] = now;\n      }\n      \n      setError(err.message || 'Health check failed');\n      \n      if (!error) {\n        setHealth(prev => ({\n          ...prev,\n          backend: 'error'\n        }));\n      }\n      \n      return null;\n    }\n  }, [error, processHealthStatus]);\n\n  // Start monitoring\n  const startMonitoring = useCallback(() => {\n    if (isMonitoring) return;\n    \n    setIsMonitoring(true);\n    \n    // Subscribe to WebSocket health updates\n    if (isConnected) {\n      subscribeToHealth();\n    }\n    \n    // Initial health check\n    performFallbackHealthCheck();\n    \n    // Setup fallback polling (much less frequent)\n    const scheduleNextFallbackCheck = () => {\n      if (fallbackIntervalRef.current) {\n        clearTimeout(fallbackIntervalRef.current);\n      }\n      \n      // Only use fallback if no WebSocket updates received recently\n      const interval = hasReceivedWebSocketUpdate.current \n        ? 15 * 60 * 1000  // 15 minutes when WebSocket working\n        : 5 * 60 * 1000;  // 5 minutes when WebSocket not working\n      \n      fallbackIntervalRef.current = setTimeout(() => {\n        // Reset WebSocket flag and check if we need fallback\n        hasReceivedWebSocketUpdate.current = false;\n        \n        performFallbackHealthCheck().then(() => {\n          if (isMonitoring) {\n            scheduleNextFallbackCheck();\n          }\n        });\n      }, interval);\n    };\n    \n    scheduleNextFallbackCheck();\n  }, [isMonitoring, isConnected, subscribeToHealth, performFallbackHealthCheck]);\n\n  // Stop monitoring\n  const stopMonitoring = useCallback(() => {\n    if (fallbackIntervalRef.current) {\n      clearTimeout(fallbackIntervalRef.current);\n      fallbackIntervalRef.current = null;\n    }\n    \n    unsubscribeFromHealth();\n    setIsMonitoring(false);\n  }, [unsubscribeFromHealth]);\n\n  // Auto-start monitoring\n  useEffect(() => {\n    if (autoStart) {\n      startMonitoring();\n    }\n    \n    return () => {\n      stopMonitoring();\n    };\n  }, [autoStart, startMonitoring, stopMonitoring]);\n\n  // Subscribe to WebSocket when connected\n  useEffect(() => {\n    if (isConnected && isMonitoring) {\n      subscribeToHealth();\n    }\n  }, [isConnected, isMonitoring]); // Removed subscribeToHealth dependency that was causing infinite loop\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (fallbackIntervalRef.current) {\n        clearTimeout(fallbackIntervalRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    health,\n    systemHealth,\n    isMonitoring,\n    lastCheck,\n    error,\n    uptime,\n    metrics,\n    serviceDetails,\n    isConnected: isConnected,\n    getHealthSummary,\n    getServiceStatus,\n    formatUptime,\n    startMonitoring,\n    stopMonitoring,\n    performHealthCheck: performFallbackHealthCheck // Keep for manual refresh\n  };\n};\n\nexport default useHealthMonitoring; "],"mappings":";AAAA,SAASA,SAAS,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,MAAM,EAAEC,OAAO,QAAQ,OAAO;AACzE,SAASC,gBAAgB,QAAQ,QAAQ;AACzC,OAAOC,YAAY,MAAM,gBAAgB;AAEzC,MAAMC,mBAAmB,GAAGA,CAACC,OAAO,GAAG,CAAC,CAAC,KAAK;EAAAC,EAAA;EAC5C,MAAM;IACJC,mBAAmB,GAAG,IAAI;IAC1BC,SAAS,GAAG;EACd,CAAC,GAAGH,OAAO;EAEX,MAAM,CAACI,MAAM,EAAEC,SAAS,CAAC,GAAGZ,QAAQ,CAAC;IACnCa,OAAO,EAAE,SAAS;IAClBC,QAAQ,EAAE,SAAS;IACnBC,SAAS,EAAE,SAAS;IACpBC,eAAe,EAAE;EACnB,CAAC,CAAC;EAEF,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGlB,QAAQ,CAAC,KAAK,CAAC;EACvD,MAAM,CAACmB,SAAS,EAAEC,YAAY,CAAC,GAAGpB,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACqB,KAAK,EAAEC,QAAQ,CAAC,GAAGtB,QAAQ,CAAC,IAAI,CAAC;EACxC,MAAM,CAACuB,MAAM,EAAEC,SAAS,CAAC,GAAGxB,QAAQ,CAAC,IAAI,CAAC;EAC1C,MAAM,CAACyB,OAAO,EAAEC,UAAU,CAAC,GAAG1B,QAAQ,CAAC;IACrC2B,WAAW,EAAE,CAAC;IACdC,iBAAiB,EAAE,CAAC;IACpBC,SAAS,EAAE,CAAC;IACZC,SAAS,EAAE;EACb,CAAC,CAAC;EACF,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGhC,QAAQ,CAAC,CAAC,CAAC,CAAC;;EAExD;EACA,MAAM;IACJiC,WAAW;IACXC,YAAY;IACZC,iBAAiB;IACjBC;EACF,CAAC,GAAG/B,YAAY,CAAC,CAAC;;EAElB;EACA,MAAMgC,iBAAiB,GAAGnC,MAAM,CAAC,CAAC,CAAC,CAAC;EACpC,MAAMoC,mBAAmB,GAAGpC,MAAM,CAAC,IAAI,CAAC;EACxC,MAAMqC,WAAW,GAAGrC,MAAM,CAAC,CAAC,CAAC;EAC7B,MAAMsC,0BAA0B,GAAGtC,MAAM,CAAC,KAAK,CAAC;EAChD,MAAMuC,aAAa,GAAGvC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;EAElC;EACA,MAAMwC,YAAY,GAAGvC,OAAO,CAAC,MAAM;IACjC,MAAMwC,QAAQ,GAAGC,MAAM,CAACC,MAAM,CAAClC,MAAM,CAAC;IACtC,IAAIgC,QAAQ,CAACG,QAAQ,CAAC,OAAO,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;MAC9D,OAAO,OAAO;IAChB;IACA,IAAIH,QAAQ,CAACG,QAAQ,CAAC,WAAW,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,UAAU,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,cAAc,CAAC,EAAE;MACxG,OAAO,WAAW;IACpB;IACA,IAAIH,QAAQ,CAACI,KAAK,CAACC,MAAM,IAAIA,MAAM,KAAK,SAAS,IAAIA,MAAM,KAAK,SAAS,IAAIA,MAAM,KAAK,WAAW,IAAIA,MAAM,KAAK,QAAQ,CAAC,EAAE;MAC3H,OAAO,SAAS;IAClB;IACA,OAAO,SAAS;EAClB,CAAC,EAAE,CAACrC,MAAM,CAAC,CAAC;;EAEZ;EACA,MAAMsC,SAAS,GAAGhD,WAAW,CAAC,CAACiD,OAAO,EAAEC,SAAS,GAAG,IAAI,KAAK;IAC3D,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;IACtB,MAAME,UAAU,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;;IAEnC,IAAI,CAACH,SAAS,EAAE;MACd,OAAO,IAAI,CAAC,CAAC;IACf;IAEA,IAAIC,GAAG,GAAGb,WAAW,CAACgB,OAAO,GAAGD,UAAU,EAAE;MAC1Cf,WAAW,CAACgB,OAAO,GAAGH,GAAG;MACzB,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMI,gBAAgB,GAAGvD,WAAW,CAAC,MAAM;IACzC,MAAMwD,QAAQ,GAAGb,MAAM,CAACC,MAAM,CAAClC,MAAM,CAAC;IACtC,MAAM+C,eAAe,GAAGD,QAAQ,CAACE,MAAM,CAACX,MAAM,IAC5CA,MAAM,KAAK,SAAS,IAAIA,MAAM,KAAK,SAAS,IAAIA,MAAM,KAAK,WAAW,IAAIA,MAAM,KAAK,QACvF,CAAC,CAACY,MAAM;IAER,OAAO;MACLH,QAAQ,EAAEA,QAAQ,CAACG,MAAM;MACzBC,OAAO,EAAEH,eAAe;MACxBI,SAAS,EAAEL,QAAQ,CAACG,MAAM,GAAGF,eAAe;MAC5CnC,MAAM,EAAEA,MAAM,IAAI;IACpB,CAAC;EACH,CAAC,EAAE,CAACZ,MAAM,EAAEY,MAAM,CAAC,CAAC;;EAEpB;EACA,MAAMwC,gBAAgB,GAAG9D,WAAW,CAAE+D,WAAW,IAAK;IACpD,MAAMhB,MAAM,GAAGrC,MAAM,CAACqD,WAAW,CAAC,IAAI,SAAS;IAC/C,MAAMC,OAAO,GAAGlC,cAAc,CAACiC,WAAW,CAAC,IAAI,CAAC,CAAC;IAEjD,OAAO;MACLhB,MAAM;MACNkB,WAAW,EAAED,OAAO,CAACC,WAAW,KAAK/C,SAAS,GAAGA,SAAS,CAACgD,kBAAkB,CAAC,CAAC,GAAG,OAAO,CAAC;MAC1FC,YAAY,EAAEH,OAAO,CAACG,YAAY;MAClC/C,KAAK,EAAE4C,OAAO,CAAC5C,KAAK;MACpB4C;IACF,CAAC;EACH,CAAC,EAAE,CAACtD,MAAM,EAAEoB,cAAc,EAAEZ,SAAS,CAAC,CAAC;;EAEvC;EACA,MAAMkD,YAAY,GAAGpE,WAAW,CAAEqE,QAAQ,IAAK;IAC7C,IAAI,CAACA,QAAQ,IAAIA,QAAQ,GAAG,CAAC,EAAE,OAAO,SAAS;IAE/C,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACH,QAAQ,GAAG,IAAI,CAAC;IAC3C,MAAMI,OAAO,GAAGF,IAAI,CAACC,KAAK,CAACF,OAAO,GAAG,EAAE,CAAC;IACxC,MAAMI,KAAK,GAAGH,IAAI,CAACC,KAAK,CAACC,OAAO,GAAG,EAAE,CAAC;IACtC,MAAME,IAAI,GAAGJ,IAAI,CAACC,KAAK,CAACE,KAAK,GAAG,EAAE,CAAC;IAEnC,IAAIC,IAAI,GAAG,CAAC,EAAE;MACZ,OAAO,GAAGA,IAAI,KAAKD,KAAK,GAAG,EAAE,KAAKD,OAAO,GAAG,EAAE,GAAG;IACnD,CAAC,MAAM,IAAIC,KAAK,GAAG,CAAC,EAAE;MACpB,OAAO,GAAGA,KAAK,KAAKD,OAAO,GAAG,EAAE,GAAG;IACrC,CAAC,MAAM,IAAIA,OAAO,GAAG,CAAC,EAAE;MACtB,OAAO,GAAGA,OAAO,KAAKH,OAAO,GAAG,EAAE,GAAG;IACvC,CAAC,MAAM;MACL,OAAO,GAAGA,OAAO,GAAG;IACtB;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMM,mBAAmB,GAAG5E,WAAW,CAAE6E,UAAU,IAAK;IAAA,IAAAC,oBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;IACtD,IAAI,CAACR,UAAU,EAAE;IAEjB,MAAMS,SAAS,GAAG;MAChB1E,OAAO,EAAE,EAAAkE,oBAAA,GAAAD,UAAU,CAACrB,QAAQ,cAAAsB,oBAAA,wBAAAC,qBAAA,GAAnBD,oBAAA,CAAqBlE,OAAO,cAAAmE,qBAAA,uBAA5BA,qBAAA,CAA8BhC,MAAM,KAAI,SAAS;MAC1DlC,QAAQ,EAAE,EAAAmE,qBAAA,GAAAH,UAAU,CAACrB,QAAQ,cAAAwB,qBAAA,wBAAAC,qBAAA,GAAnBD,qBAAA,CAAqBnE,QAAQ,cAAAoE,qBAAA,uBAA7BA,qBAAA,CAA+BlC,MAAM,KAAI,SAAS;MAC5DjC,SAAS,EAAE,EAAAoE,qBAAA,GAAAL,UAAU,CAACrB,QAAQ,cAAA0B,qBAAA,wBAAAC,qBAAA,GAAnBD,qBAAA,CAAqBpE,SAAS,cAAAqE,qBAAA,uBAA9BA,qBAAA,CAAgCpC,MAAM,KAAI,SAAS;MAC9DhC,eAAe,EAAE,EAAAqE,qBAAA,GAAAP,UAAU,CAACrB,QAAQ,cAAA4B,qBAAA,wBAAAC,qBAAA,GAAnBD,qBAAA,CAAqBrE,eAAe,cAAAsE,qBAAA,uBAApCA,qBAAA,CAAsCtC,MAAM,KAAI;IACnE,CAAC;;IAED;IACA,MAAMwC,UAAU,GAAG5C,MAAM,CAAC6C,IAAI,CAACF,SAAS,CAAC,CAACG,IAAI,CAC5CC,OAAO,IAAItD,iBAAiB,CAACkB,OAAO,CAACoC,OAAO,CAAC,KAAKJ,SAAS,CAACI,OAAO,CACrE,CAAC;IAED,IAAIH,UAAU,IAAI,CAACnD,iBAAiB,CAACkB,OAAO,CAAC1C,OAAO,EAAE;MAAA,IAAA+E,mBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,oBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA;MACpD9D,iBAAiB,CAACkB,OAAO,GAAG;QAAE,GAAGgC;MAAU,CAAC;MAC5C3E,SAAS,CAAC2E,SAAS,CAAC;MACpBnE,YAAY,CAAC,IAAIiC,IAAI,CAAC,CAAC,CAAC;MACxB/B,QAAQ,CAAC,IAAI,CAAC;;MAEd;MACA,MAAM8E,iBAAiB,GAAGxD,MAAM,CAACyD,OAAO,CAACd,SAAS,CAAC,CAChD5B,MAAM,CAAC,CAAC,CAAC2C,CAAC,EAAEtD,MAAM,CAAC,KAAKA,MAAM,KAAK,WAAW,IAAIA,MAAM,KAAK,OAAO,IAAIA,MAAM,KAAK,SAAS,CAAC,CAC7FuD,GAAG,CAAC,CAAC,CAACZ,OAAO,EAAEW,CAAC,CAAC,KAAKX,OAAO,CAAC;MAEjC,IAAIS,iBAAiB,CAACxC,MAAM,GAAG,CAAC,EAAE;QAChC,IAAIX,SAAS,CAAC,gBAAgB,EAAE,KAAK,CAAC,EAAE;UACtCuD,OAAO,CAACC,IAAI,CAAC,oBAAoB,EAAEL,iBAAiB,CAAC;QACvD;MACF,CAAC,MAAM;QACL;QACA;QACA,IAAIZ,UAAU,IAAIvC,SAAS,CAAC,gBAAgB,EAAE,IAAI,CAAC,EAAE;UACnDuD,OAAO,CAACE,GAAG,CAAC,yBAAyB,CAAC;QACxC;MACF;;MAEA;MACA,IAAI5B,UAAU,CAACvD,MAAM,EAAE;QACrBC,SAAS,CAACsD,UAAU,CAACvD,MAAM,GAAG,IAAI,CAAC;MACrC;MAEAG,UAAU,CAAC;QACTC,WAAW,EAAE,EAAAiE,mBAAA,GAAAd,UAAU,CAACrD,OAAO,cAAAmE,mBAAA,uBAAlBA,mBAAA,CAAoBjE,WAAW,KAAI,CAAC;QACjDC,iBAAiB,EAAE,EAAAiE,qBAAA,GAAAf,UAAU,CAACrB,QAAQ,cAAAoC,qBAAA,wBAAAC,qBAAA,GAAnBD,qBAAA,CAAqB9E,SAAS,cAAA+E,qBAAA,uBAA9BA,qBAAA,CAAgCa,WAAW,KAAI,CAAC;QACnE9E,SAAS,EAAE,EAAAkE,oBAAA,GAAAjB,UAAU,CAACrD,OAAO,cAAAsE,oBAAA,uBAAlBA,oBAAA,CAAoBlE,SAAS,KAAI,CAAC;QAC7CC,SAAS,EAAEgD,UAAU,CAAChD,SAAS,IAAI;MACrC,CAAC,CAAC;MAEFE,iBAAiB,CAAC;QAChBnB,OAAO,EAAE,EAAAmF,qBAAA,GAAAlB,UAAU,CAACrB,QAAQ,cAAAuC,qBAAA,uBAAnBA,qBAAA,CAAqBnF,OAAO,KAAI,CAAC,CAAC;QAC3CC,QAAQ,EAAE,EAAAmF,qBAAA,GAAAnB,UAAU,CAACrB,QAAQ,cAAAwC,qBAAA,uBAAnBA,qBAAA,CAAqBnF,QAAQ,KAAI,CAAC,CAAC;QAC7CC,SAAS,EAAE,EAAAmF,sBAAA,GAAApB,UAAU,CAACrB,QAAQ,cAAAyC,sBAAA,uBAAnBA,sBAAA,CAAqBnF,SAAS,KAAI,CAAC,CAAC;QAC/CC,eAAe,EAAE,EAAAmF,sBAAA,GAAArB,UAAU,CAACrB,QAAQ,cAAA0C,sBAAA,uBAAnBA,sBAAA,CAAqBnF,eAAe,KAAI,CAAC;MAC5D,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAACiC,SAAS,CAAC,CAAC;;EAEf;EACAlD,SAAS,CAAC,MAAM;IACd,IAAImC,YAAY,EAAE;MAChBM,0BAA0B,CAACe,OAAO,GAAG,IAAI;MACzCsB,mBAAmB,CAAC3C,YAAY,CAAC;IACnC;EACF,CAAC,EAAE,CAACA,YAAY,EAAE2C,mBAAmB,CAAC,CAAC;;EAEvC;EACA,MAAM+B,0BAA0B,GAAG3G,WAAW,CAAC,YAAY;IACzD,IAAI;MACF,MAAM4G,QAAQ,GAAG,MAAMzG,gBAAgB,CAAC,CAAC;MACzCyE,mBAAmB,CAACgC,QAAQ,CAAC;MAC7B,OAAOA,QAAQ;IACjB,CAAC,CAAC,OAAOC,GAAG,EAAE;MACZ;MACA,MAAM1D,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;MACtB,MAAM2D,QAAQ,GAAGD,GAAG,CAAC5D,OAAO,IAAI,eAAe;MAE/C,IAAI,CAACT,aAAa,CAACc,OAAO,CAACwD,QAAQ,CAAC,IAC/B3D,GAAG,GAAGX,aAAa,CAACc,OAAO,CAACwD,QAAQ,CAAC,GAAI,KAAK,EAAE;QAAE;QACrDP,OAAO,CAACnF,KAAK,CAAC,iCAAiC,EAAEyF,GAAG,CAAC5D,OAAO,CAAC;QAC7DT,aAAa,CAACc,OAAO,CAACwD,QAAQ,CAAC,GAAG3D,GAAG;MACvC;MAEA9B,QAAQ,CAACwF,GAAG,CAAC5D,OAAO,IAAI,qBAAqB,CAAC;MAE9C,IAAI,CAAC7B,KAAK,EAAE;QACVT,SAAS,CAACoG,IAAI,KAAK;UACjB,GAAGA,IAAI;UACPnG,OAAO,EAAE;QACX,CAAC,CAAC,CAAC;MACL;MAEA,OAAO,IAAI;IACb;EACF,CAAC,EAAE,CAACQ,KAAK,EAAEwD,mBAAmB,CAAC,CAAC;;EAEhC;EACA,MAAMoC,eAAe,GAAGhH,WAAW,CAAC,MAAM;IACxC,IAAIgB,YAAY,EAAE;IAElBC,eAAe,CAAC,IAAI,CAAC;;IAErB;IACA,IAAIe,WAAW,EAAE;MACfE,iBAAiB,CAAC,CAAC;IACrB;;IAEA;IACAyE,0BAA0B,CAAC,CAAC;;IAE5B;IACA,MAAMM,yBAAyB,GAAGA,CAAA,KAAM;MACtC,IAAI5E,mBAAmB,CAACiB,OAAO,EAAE;QAC/B4D,YAAY,CAAC7E,mBAAmB,CAACiB,OAAO,CAAC;MAC3C;;MAEA;MACA,MAAM6D,QAAQ,GAAG5E,0BAA0B,CAACe,OAAO,GAC/C,EAAE,GAAG,EAAE,GAAG,IAAI,CAAE;MAAA,EAChB,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAE;;MAEpBjB,mBAAmB,CAACiB,OAAO,GAAG8D,UAAU,CAAC,MAAM;QAC7C;QACA7E,0BAA0B,CAACe,OAAO,GAAG,KAAK;QAE1CqD,0BAA0B,CAAC,CAAC,CAACU,IAAI,CAAC,MAAM;UACtC,IAAIrG,YAAY,EAAE;YAChBiG,yBAAyB,CAAC,CAAC;UAC7B;QACF,CAAC,CAAC;MACJ,CAAC,EAAEE,QAAQ,CAAC;IACd,CAAC;IAEDF,yBAAyB,CAAC,CAAC;EAC7B,CAAC,EAAE,CAACjG,YAAY,EAAEgB,WAAW,EAAEE,iBAAiB,EAAEyE,0BAA0B,CAAC,CAAC;;EAE9E;EACA,MAAMW,cAAc,GAAGtH,WAAW,CAAC,MAAM;IACvC,IAAIqC,mBAAmB,CAACiB,OAAO,EAAE;MAC/B4D,YAAY,CAAC7E,mBAAmB,CAACiB,OAAO,CAAC;MACzCjB,mBAAmB,CAACiB,OAAO,GAAG,IAAI;IACpC;IAEAnB,qBAAqB,CAAC,CAAC;IACvBlB,eAAe,CAAC,KAAK,CAAC;EACxB,CAAC,EAAE,CAACkB,qBAAqB,CAAC,CAAC;;EAE3B;EACArC,SAAS,CAAC,MAAM;IACd,IAAIW,SAAS,EAAE;MACbuG,eAAe,CAAC,CAAC;IACnB;IAEA,OAAO,MAAM;MACXM,cAAc,CAAC,CAAC;IAClB,CAAC;EACH,CAAC,EAAE,CAAC7G,SAAS,EAAEuG,eAAe,EAAEM,cAAc,CAAC,CAAC;;EAEhD;EACAxH,SAAS,CAAC,MAAM;IACd,IAAIkC,WAAW,IAAIhB,YAAY,EAAE;MAC/BkB,iBAAiB,CAAC,CAAC;IACrB;EACF,CAAC,EAAE,CAACF,WAAW,EAAEhB,YAAY,CAAC,CAAC,CAAC,CAAC;;EAEjC;EACAlB,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX,IAAIuC,mBAAmB,CAACiB,OAAO,EAAE;QAC/B4D,YAAY,CAAC7E,mBAAmB,CAACiB,OAAO,CAAC;MAC3C;IACF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACL5C,MAAM;IACN+B,YAAY;IACZzB,YAAY;IACZE,SAAS;IACTE,KAAK;IACLE,MAAM;IACNE,OAAO;IACPM,cAAc;IACdE,WAAW,EAAEA,WAAW;IACxBuB,gBAAgB;IAChBO,gBAAgB;IAChBM,YAAY;IACZ4C,eAAe;IACfM,cAAc;IACdC,kBAAkB,EAAEZ,0BAA0B,CAAC;EACjD,CAAC;AACH,CAAC;AAACpG,EAAA,CA1TIF,mBAAmB;EAAA,QA+BnBD,YAAY;AAAA;AA6RlB,eAAeC,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}