{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback, useRef } from 'react';\nimport io from 'socket.io-client';\nconst useWebSocket = () => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [healthStatus, setHealthStatus] = useState(null);\n  const [isHealthSubscribed, setIsHealthSubscribed] = useState(false);\n  const [dashboardStatus, setDashboardStatus] = useState(null);\n  const [isDashboardSubscribed, setIsDashboardSubscribed] = useState(false);\n\n  // Use refs to avoid dependency issues\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const socketRef = useRef(null);\n  const isHealthSubscribedRef = useRef(false);\n  const isDashboardSubscribedRef = useRef(false);\n  const lastErrorTime = useRef(0);\n  const maxReconnectAttempts = 5;\n\n  // Smart error logging - avoid console spam\n  const logError = useCallback((message, error) => {\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n\n    // Only log errors every 5 minutes to avoid spam\n    if (now - lastErrorTime.current > fiveMinutes) {\n      console.error(message, (error === null || error === void 0 ? void 0 : error.message) || error);\n      lastErrorTime.current = now;\n    }\n  }, []);\n\n  // Initialize WebSocket connection - removed problematic dependencies\n  useEffect(() => {\n    // Smart WebSocket URL detection for distributed architecture\n    const getWsUrl = () => {\n      // If we're in a browser environment, dynamically determine from current page location\n      if (typeof window !== 'undefined') {\n        // Use environment variable if set, otherwise dynamically determine from current location\n        if (process.env.REACT_APP_WS_URL) {\n          return process.env.REACT_APP_WS_URL;\n        }\n\n        // Get current host and construct backend URL\n        const {\n          protocol,\n          hostname\n        } = window.location;\n\n        // Special handling for distributed architecture\n        // If accessing from client VM (10.0.44.3), use central backend IP (10.0.44.32)\n        let targetHost = hostname;\n        if (hostname === '10.0.44.3') {\n          targetHost = '10.0.44.32';\n          console.log('üîß WebSocket: Client VM detected, routing to central backend:', targetHost);\n        }\n        return `${protocol}//${targetHost}:5000`;\n      }\n      // If we're in a Node.js environment (SSR), use the container URL\n      return process.env.REACT_APP_WS_URL || 'http://backend:5000';\n    };\n    const WS_URL = getWsUrl();\n\n    // Clean up any existing connection\n    if (socketRef.current) {\n      socketRef.current.disconnect();\n      socketRef.current = null;\n    }\n    const newSocket = io(WS_URL, {\n      transports: ['websocket', 'polling'],\n      timeout: 10000,\n      forceNew: true,\n      autoConnect: true\n    });\n    socketRef.current = newSocket;\n    newSocket.on('connect', () => {\n      // Removed console.log to reduce spam\n      setIsConnected(true);\n      setSocket(newSocket);\n      reconnectAttemptsRef.current = 0;\n\n      // Resubscribe to health updates if we were subscribed before\n      if (isHealthSubscribedRef.current) {\n        newSocket.emit('subscribe-health');\n      }\n\n      // Resubscribe to dashboard updates if we were subscribed before\n      if (isDashboardSubscribedRef.current) {\n        newSocket.emit('subscribe-dashboard');\n      }\n    });\n    newSocket.on('disconnect', reason => {\n      // Only log disconnections, not normal operations\n      if (reason !== 'io client disconnect') {\n        console.log('‚ùå WebSocket disconnected:', reason);\n      }\n      setIsConnected(false);\n      setHealthStatus(null);\n\n      // Auto-reconnect with exponential backoff (but limit attempts)\n      if (reason !== 'io client disconnect' && reconnectAttemptsRef.current < maxReconnectAttempts) {\n        const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 30000);\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n        }\n        reconnectTimeoutRef.current = setTimeout(() => {\n          reconnectAttemptsRef.current++;\n          // Only log actual reconnection attempts, not every disconnect\n          if (reconnectAttemptsRef.current <= 2) {\n            console.log(`üîÑ Reconnecting... (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\n          }\n          newSocket.connect();\n        }, delay);\n      } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n        logError('üö® WebSocket max reconnection attempts reached. Please refresh the page.');\n      }\n    });\n    newSocket.on('connect_error', error => {\n      logError('üîå WebSocket connection error:', error);\n      setIsConnected(false);\n    });\n\n    // Handle health status updates\n    newSocket.on('health-status', data => {\n      setHealthStatus(data);\n    });\n\n    // Handle dashboard status updates\n    newSocket.on('dashboard-status', data => {\n      setDashboardStatus(data);\n    });\n\n    // Handle dashboard data updates\n    newSocket.on('dashboard-update', data => {\n      console.log('üìä Dashboard update received:', data);\n      // This will be handled by the dashboard component\n    });\n\n    // Handle specific data type updates\n    newSocket.on('data-update', data => {\n      console.log('üìä Data update received:', data);\n      // This will be handled by the dashboard component\n    });\n\n    // Multi-collection event handlers\n    newSocket.on('new-event', event => {\n      // Emit normalized event for components to handle\n      newSocket.emit('normalized-event', {\n        ...event,\n        collection: 'events',\n        timestamp: event.timestamp || new Date().toISOString()\n      });\n    });\n\n    // Handle new scan alerts\n    newSocket.on('new-scan-alert', alert => {\n      console.log('New scan alert received:', alert);\n      const normalizedEvent = {\n        ...alert,\n        collection: 'scan_alerts',\n        timestamp: new Date().toISOString()\n      };\n      // Assuming onEvent is defined elsewhere or will be added\n      // newSocket.emit('normalized-event', normalizedEvent); \n    });\n\n    // Handle new deception detection\n    newSocket.on('new-deception-activity', activity => {\n      console.log('New deception activity received:', activity);\n      const normalizedEvent = {\n        ...activity,\n        collection: 'deception_detection',\n        timestamp: new Date().toISOString()\n      };\n      // Assuming onEvent is defined elsewhere or will be added\n      // newSocket.emit('normalized-event', normalizedEvent); \n    });\n\n    // Legacy event handlers for backward compatibility\n    newSocket.on('new-zeek-alert', alert => {\n      console.log('Legacy Zeek alert received:', alert);\n      const normalizedEvent = {\n        ...alert,\n        collection: 'scan_alerts',\n        timestamp: new Date().toISOString()\n      };\n      // Assuming onEvent is defined elsewhere or will be added\n      // newSocket.emit('normalized-event', normalizedEvent); \n    });\n    newSocket.on('new-honeypot-event', event => {\n      // Emit normalized event for components to handle\n      newSocket.emit('normalized-event', {\n        ...event,\n        collection: 'honeypot_events',\n        timestamp: event.timestamp || new Date().toISOString()\n      });\n    });\n    newSocket.on('new-nmap-detection', event => {\n      // Special handling for Nmap detections\n      newSocket.emit('normalized-event', {\n        ...event,\n        collection: 'events',\n        event_type: event.event_type || 'nmap_detection',\n        timestamp: event.timestamp || new Date().toISOString(),\n        isNmapDetection: true\n      });\n    });\n\n    // Generic error handler\n    newSocket.on('error', error => {\n      logError('üîå WebSocket error:', error);\n    });\n    setSocket(newSocket);\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n        reconnectTimeoutRef.current = null;\n      }\n      if (socketRef.current) {\n        socketRef.current.disconnect();\n        socketRef.current = null;\n      }\n    };\n  }, []); // Removed problematic dependencies\n\n  // Subscribe to events\n  const subscribe = useCallback((eventName, handler) => {\n    if (!socket) return () => {};\n    socket.on(eventName, handler);\n\n    // Return unsubscribe function\n    return () => {\n      if (socket) {\n        socket.off(eventName, handler);\n      }\n    };\n  }, [socket]);\n\n  // Unsubscribe from events\n  const unsubscribe = useCallback((eventName, handler) => {\n    if (!socket) return;\n    socket.off(eventName, handler);\n  }, [socket]);\n\n  // Subscribe to health updates\n  const subscribeToHealth = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('subscribe-health');\n      setIsHealthSubscribed(true);\n      isHealthSubscribedRef.current = true;\n    }\n  }, [socket, isConnected]);\n\n  // Unsubscribe from health updates\n  const unsubscribeFromHealth = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('unsubscribe-health');\n      setIsHealthSubscribed(false);\n      isHealthSubscribedRef.current = false;\n    }\n  }, [socket, isConnected]);\n\n  // Subscribe to dashboard updates\n  const subscribeToDashboard = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('subscribe-dashboard');\n      setIsDashboardSubscribed(true);\n      isDashboardSubscribedRef.current = true;\n    }\n  }, [socket, isConnected]);\n\n  // Unsubscribe from dashboard updates\n  const unsubscribeFromDashboard = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('unsubscribe-dashboard');\n      setIsDashboardSubscribed(false);\n      isDashboardSubscribedRef.current = false;\n    }\n  }, [socket, isConnected]);\n\n  // Subscribe to specific data type updates\n  const subscribeToDataType = useCallback(dataType => {\n    if (socket && isConnected && dataType) {\n      socket.emit('subscribe-data-type', dataType);\n    }\n  }, [socket, isConnected]);\n\n  // Unsubscribe from specific data type updates\n  const unsubscribeFromDataType = useCallback(dataType => {\n    if (socket && isConnected && dataType) {\n      socket.emit('unsubscribe-data-type', dataType);\n    }\n  }, [socket, isConnected]);\n\n  // Join honeypot room\n  const joinHoneypotRoom = useCallback(honeypotId => {\n    if (!socket || !honeypotId) return;\n    socket.emit('join-honeypot', honeypotId);\n  }, [socket]);\n\n  // Leave honeypot room\n  const leaveHoneypotRoom = useCallback(honeypotId => {\n    if (!socket || !honeypotId) return;\n    socket.emit('leave-honeypot', honeypotId);\n  }, [socket]);\n\n  // Subscribe to enhanced events (multi-collection)\n  const subscribeToEvents = useCallback(() => {\n    if (!socket) return;\n    socket.emit('subscribe-events');\n  }, [socket]);\n\n  // Unsubscribe from enhanced events\n  const unsubscribeFromEvents = useCallback(() => {\n    if (!socket) return;\n    socket.emit('unsubscribe-events');\n  }, [socket]);\n\n  // Subscribe to Nmap detections specifically\n  const subscribeToNmapDetections = useCallback(() => {\n    if (!socket) return;\n    socket.emit('subscribe-nmap-detections');\n  }, [socket]);\n\n  // Unsubscribe from Nmap detections\n  const unsubscribeFromNmapDetections = useCallback(() => {\n    if (!socket) return;\n    socket.emit('unsubscribe-nmap-detections');\n  }, [socket]);\n\n  // Subscribe to threat feed updates\n  const subscribeToThreatFeed = useCallback(() => {\n    if (!socket) return;\n    socket.emit('subscribe-threat-feed');\n  }, [socket]);\n\n  // Unsubscribe from threat feed updates\n  const unsubscribeFromThreatFeed = useCallback(() => {\n    if (!socket) return;\n    socket.emit('unsubscribe-threat-feed');\n  }, [socket]);\n\n  // Force reconnect function\n  const forceReconnect = useCallback(() => {\n    if (socketRef.current) {\n      reconnectAttemptsRef.current = 0;\n      socketRef.current.disconnect();\n      socketRef.current.connect();\n    }\n  }, []);\n  return {\n    socket,\n    isConnected,\n    subscribe,\n    unsubscribe,\n    subscribeToHealth,\n    unsubscribeFromHealth,\n    healthStatus,\n    isHealthSubscribed,\n    subscribeToDashboard,\n    unsubscribeFromDashboard,\n    dashboardStatus,\n    isDashboardSubscribed,\n    joinHoneypotRoom,\n    leaveHoneypotRoom,\n    subscribeToEvents,\n    unsubscribeFromEvents,\n    subscribeToNmapDetections,\n    unsubscribeFromNmapDetections,\n    subscribeToThreatFeed,\n    unsubscribeFromThreatFeed,\n    forceReconnect\n  };\n};\n_s(useWebSocket, \"//+Z0rHgpzRX+imPcfu+nSlR1Lo=\");\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useState","useCallback","useRef","io","useWebSocket","_s","socket","setSocket","isConnected","setIsConnected","healthStatus","setHealthStatus","isHealthSubscribed","setIsHealthSubscribed","dashboardStatus","setDashboardStatus","isDashboardSubscribed","setIsDashboardSubscribed","reconnectTimeoutRef","reconnectAttemptsRef","socketRef","isHealthSubscribedRef","isDashboardSubscribedRef","lastErrorTime","maxReconnectAttempts","logError","message","error","now","Date","fiveMinutes","current","console","getWsUrl","window","process","env","REACT_APP_WS_URL","protocol","hostname","location","targetHost","log","WS_URL","disconnect","newSocket","transports","timeout","forceNew","autoConnect","on","emit","reason","delay","Math","min","pow","clearTimeout","setTimeout","connect","data","event","collection","timestamp","toISOString","alert","normalizedEvent","activity","event_type","isNmapDetection","subscribe","eventName","handler","off","unsubscribe","subscribeToHealth","unsubscribeFromHealth","subscribeToDashboard","unsubscribeFromDashboard","subscribeToDataType","dataType","unsubscribeFromDataType","joinHoneypotRoom","honeypotId","leaveHoneypotRoom","subscribeToEvents","unsubscribeFromEvents","subscribeToNmapDetections","unsubscribeFromNmapDetections","subscribeToThreatFeed","unsubscribeFromThreatFeed","forceReconnect"],"sources":["/home/demon/distributed-architecture/central-infrastructure/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useState, useCallback, useRef } from 'react';\nimport io from 'socket.io-client';\n\nconst useWebSocket = () => {\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [healthStatus, setHealthStatus] = useState(null);\n  const [isHealthSubscribed, setIsHealthSubscribed] = useState(false);\n  const [dashboardStatus, setDashboardStatus] = useState(null);\n  const [isDashboardSubscribed, setIsDashboardSubscribed] = useState(false);\n  \n  // Use refs to avoid dependency issues\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const socketRef = useRef(null);\n  const isHealthSubscribedRef = useRef(false);\n  const isDashboardSubscribedRef = useRef(false);\n  const lastErrorTime = useRef(0);\n  const maxReconnectAttempts = 5;\n\n  // Smart error logging - avoid console spam\n  const logError = useCallback((message, error) => {\n    const now = Date.now();\n    const fiveMinutes = 5 * 60 * 1000;\n    \n    // Only log errors every 5 minutes to avoid spam\n    if (now - lastErrorTime.current > fiveMinutes) {\n      console.error(message, error?.message || error);\n      lastErrorTime.current = now;\n    }\n  }, []);\n\n  // Initialize WebSocket connection - removed problematic dependencies\n  useEffect(() => {\n    // Smart WebSocket URL detection for distributed architecture\n    const getWsUrl = () => {\n      // If we're in a browser environment, dynamically determine from current page location\n      if (typeof window !== 'undefined') {\n        // Use environment variable if set, otherwise dynamically determine from current location\n        if (process.env.REACT_APP_WS_URL) {\n          return process.env.REACT_APP_WS_URL;\n        }\n        \n        // Get current host and construct backend URL\n        const { protocol, hostname } = window.location;\n        \n        // Special handling for distributed architecture\n            // If accessing from client VM (10.0.44.3), use central backend IP (10.0.44.32)\n    let targetHost = hostname;\n    if (hostname === '10.0.44.3') {\n      targetHost = '10.0.44.32';\n      console.log('üîß WebSocket: Client VM detected, routing to central backend:', targetHost);\n    }\n        \n        return `${protocol}//${targetHost}:5000`;\n      }\n      // If we're in a Node.js environment (SSR), use the container URL\n      return process.env.REACT_APP_WS_URL || 'http://backend:5000';\n    };\n    \n    const WS_URL = getWsUrl();\n    \n    // Clean up any existing connection\n    if (socketRef.current) {\n      socketRef.current.disconnect();\n      socketRef.current = null;\n    }\n\n    const newSocket = io(WS_URL, {\n      transports: ['websocket', 'polling'],\n      timeout: 10000,\n      forceNew: true,\n      autoConnect: true\n    });\n\n    socketRef.current = newSocket;\n\n    newSocket.on('connect', () => {\n      // Removed console.log to reduce spam\n      setIsConnected(true);\n      setSocket(newSocket);\n      reconnectAttemptsRef.current = 0;\n      \n      // Resubscribe to health updates if we were subscribed before\n      if (isHealthSubscribedRef.current) {\n        newSocket.emit('subscribe-health');\n      }\n      \n      // Resubscribe to dashboard updates if we were subscribed before\n      if (isDashboardSubscribedRef.current) {\n        newSocket.emit('subscribe-dashboard');\n      }\n    });\n\n    newSocket.on('disconnect', (reason) => {\n      // Only log disconnections, not normal operations\n      if (reason !== 'io client disconnect') {\n        console.log('‚ùå WebSocket disconnected:', reason);\n      }\n      setIsConnected(false);\n      setHealthStatus(null);\n      \n      // Auto-reconnect with exponential backoff (but limit attempts)\n      if (reason !== 'io client disconnect' && reconnectAttemptsRef.current < maxReconnectAttempts) {\n        const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 30000);\n        \n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n        }\n        \n        reconnectTimeoutRef.current = setTimeout(() => {\n          reconnectAttemptsRef.current++;\n          // Only log actual reconnection attempts, not every disconnect\n          if (reconnectAttemptsRef.current <= 2) {\n            console.log(`üîÑ Reconnecting... (attempt ${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\n          }\n          newSocket.connect();\n        }, delay);\n      } else if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n        logError('üö® WebSocket max reconnection attempts reached. Please refresh the page.');\n      }\n    });\n\n    newSocket.on('connect_error', (error) => {\n      logError('üîå WebSocket connection error:', error);\n      setIsConnected(false);\n    });\n\n    // Handle health status updates\n    newSocket.on('health-status', (data) => {\n      setHealthStatus(data);\n    });\n\n    // Handle dashboard status updates\n    newSocket.on('dashboard-status', (data) => {\n      setDashboardStatus(data);\n    });\n\n    // Handle dashboard data updates\n    newSocket.on('dashboard-update', (data) => {\n      console.log('üìä Dashboard update received:', data);\n      // This will be handled by the dashboard component\n    });\n\n    // Handle specific data type updates\n    newSocket.on('data-update', (data) => {\n      console.log('üìä Data update received:', data);\n      // This will be handled by the dashboard component\n    });\n\n    // Multi-collection event handlers\n    newSocket.on('new-event', (event) => {\n      // Emit normalized event for components to handle\n      newSocket.emit('normalized-event', {\n        ...event,\n        collection: 'events',\n        timestamp: event.timestamp || new Date().toISOString()\n      });\n    });\n\n    // Handle new scan alerts\n    newSocket.on('new-scan-alert', (alert) => {\n      console.log('New scan alert received:', alert);\n      const normalizedEvent = {\n        ...alert,\n        collection: 'scan_alerts',\n        timestamp: new Date().toISOString()\n      };\n      // Assuming onEvent is defined elsewhere or will be added\n      // newSocket.emit('normalized-event', normalizedEvent); \n    });\n\n    // Handle new deception detection\n    newSocket.on('new-deception-activity', (activity) => {\n      console.log('New deception activity received:', activity);\n      const normalizedEvent = {\n        ...activity,\n        collection: 'deception_detection',\n        timestamp: new Date().toISOString()\n      };\n      // Assuming onEvent is defined elsewhere or will be added\n      // newSocket.emit('normalized-event', normalizedEvent); \n    });\n\n    // Legacy event handlers for backward compatibility\n    newSocket.on('new-zeek-alert', (alert) => {\n      console.log('Legacy Zeek alert received:', alert);\n      const normalizedEvent = {\n        ...alert,\n        collection: 'scan_alerts',\n        timestamp: new Date().toISOString()\n      };\n      // Assuming onEvent is defined elsewhere or will be added\n      // newSocket.emit('normalized-event', normalizedEvent); \n    });\n\n    newSocket.on('new-honeypot-event', (event) => {\n      // Emit normalized event for components to handle\n      newSocket.emit('normalized-event', {\n        ...event,\n        collection: 'honeypot_events',\n        timestamp: event.timestamp || new Date().toISOString()\n      });\n    });\n\n    newSocket.on('new-nmap-detection', (event) => {\n      // Special handling for Nmap detections\n      newSocket.emit('normalized-event', {\n        ...event,\n        collection: 'events',\n        event_type: event.event_type || 'nmap_detection',\n        timestamp: event.timestamp || new Date().toISOString(),\n        isNmapDetection: true\n      });\n    });\n\n    // Generic error handler\n    newSocket.on('error', (error) => {\n      logError('üîå WebSocket error:', error);\n    });\n\n    setSocket(newSocket);\n\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n        reconnectTimeoutRef.current = null;\n      }\n      if (socketRef.current) {\n        socketRef.current.disconnect();\n        socketRef.current = null;\n      }\n    };\n  }, []); // Removed problematic dependencies\n\n  // Subscribe to events\n  const subscribe = useCallback((eventName, handler) => {\n    if (!socket) return () => {};\n\n    socket.on(eventName, handler);\n\n    // Return unsubscribe function\n    return () => {\n      if (socket) {\n        socket.off(eventName, handler);\n      }\n    };\n  }, [socket]);\n\n  // Unsubscribe from events\n  const unsubscribe = useCallback((eventName, handler) => {\n    if (!socket) return;\n    socket.off(eventName, handler);\n  }, [socket]);\n\n  // Subscribe to health updates\n  const subscribeToHealth = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('subscribe-health');\n      setIsHealthSubscribed(true);\n      isHealthSubscribedRef.current = true;\n    }\n  }, [socket, isConnected]);\n\n  // Unsubscribe from health updates\n  const unsubscribeFromHealth = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('unsubscribe-health');\n      setIsHealthSubscribed(false);\n      isHealthSubscribedRef.current = false;\n    }\n  }, [socket, isConnected]);\n\n  // Subscribe to dashboard updates\n  const subscribeToDashboard = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('subscribe-dashboard');\n      setIsDashboardSubscribed(true);\n      isDashboardSubscribedRef.current = true;\n    }\n  }, [socket, isConnected]);\n\n  // Unsubscribe from dashboard updates\n  const unsubscribeFromDashboard = useCallback(() => {\n    if (socket && isConnected) {\n      socket.emit('unsubscribe-dashboard');\n      setIsDashboardSubscribed(false);\n      isDashboardSubscribedRef.current = false;\n    }\n  }, [socket, isConnected]);\n\n  // Subscribe to specific data type updates\n  const subscribeToDataType = useCallback((dataType) => {\n    if (socket && isConnected && dataType) {\n      socket.emit('subscribe-data-type', dataType);\n    }\n  }, [socket, isConnected]);\n\n  // Unsubscribe from specific data type updates\n  const unsubscribeFromDataType = useCallback((dataType) => {\n    if (socket && isConnected && dataType) {\n      socket.emit('unsubscribe-data-type', dataType);\n    }\n  }, [socket, isConnected]);\n\n  // Join honeypot room\n  const joinHoneypotRoom = useCallback((honeypotId) => {\n    if (!socket || !honeypotId) return;\n    socket.emit('join-honeypot', honeypotId);\n  }, [socket]);\n\n  // Leave honeypot room\n  const leaveHoneypotRoom = useCallback((honeypotId) => {\n    if (!socket || !honeypotId) return;\n    socket.emit('leave-honeypot', honeypotId);\n  }, [socket]);\n\n  // Subscribe to enhanced events (multi-collection)\n  const subscribeToEvents = useCallback(() => {\n    if (!socket) return;\n    socket.emit('subscribe-events');\n  }, [socket]);\n\n  // Unsubscribe from enhanced events\n  const unsubscribeFromEvents = useCallback(() => {\n    if (!socket) return;\n    socket.emit('unsubscribe-events');\n  }, [socket]);\n\n  // Subscribe to Nmap detections specifically\n  const subscribeToNmapDetections = useCallback(() => {\n    if (!socket) return;\n    socket.emit('subscribe-nmap-detections');\n  }, [socket]);\n\n  // Unsubscribe from Nmap detections\n  const unsubscribeFromNmapDetections = useCallback(() => {\n    if (!socket) return;\n    socket.emit('unsubscribe-nmap-detections');\n  }, [socket]);\n\n  // Subscribe to threat feed updates\n  const subscribeToThreatFeed = useCallback(() => {\n    if (!socket) return;\n    socket.emit('subscribe-threat-feed');\n  }, [socket]);\n\n  // Unsubscribe from threat feed updates\n  const unsubscribeFromThreatFeed = useCallback(() => {\n    if (!socket) return;\n    socket.emit('unsubscribe-threat-feed');\n  }, [socket]);\n\n  // Force reconnect function\n  const forceReconnect = useCallback(() => {\n    if (socketRef.current) {\n      reconnectAttemptsRef.current = 0;\n      socketRef.current.disconnect();\n      socketRef.current.connect();\n    }\n  }, []);\n\n  return {\n    socket,\n    isConnected,\n    subscribe,\n    unsubscribe,\n    subscribeToHealth,\n    unsubscribeFromHealth,\n    healthStatus,\n    isHealthSubscribed,\n    subscribeToDashboard,\n    unsubscribeFromDashboard,\n    dashboardStatus,\n    isDashboardSubscribed,\n    joinHoneypotRoom,\n    leaveHoneypotRoom,\n    subscribeToEvents,\n    unsubscribeFromEvents,\n    subscribeToNmapDetections,\n    unsubscribeFromNmapDetections,\n    subscribeToThreatFeed,\n    unsubscribeFromThreatFeed,\n    forceReconnect\n  };\n};\n\nexport default useWebSocket; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}