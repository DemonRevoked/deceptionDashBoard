{"ast":null,"code":"import{useEffect,useState,useCallback,useRef,useMemo}from'react';import{checkQuickHealth}from'../api';import useWebSocket from'./useWebSocket';const useHealthMonitoring=function(){let options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{enableNotifications=true,autoStart=true}=options;const[health,setHealth]=useState({backend:'unknown',database:'unknown',websocket:'unknown',honeypotManager:'unknown'});const[isMonitoring,setIsMonitoring]=useState(false);const[lastCheck,setLastCheck]=useState(null);const[error,setError]=useState(null);const[uptime,setUptime]=useState(null);const[metrics,setMetrics]=useState({totalEvents:0,activeConnections:0,errorRate:0,honeypots:[]});const[serviceDetails,setServiceDetails]=useState({});// Use WebSocket for real-time health updates\nconst{isConnected,healthStatus,subscribeToHealth,unsubscribeFromHealth}=useWebSocket();// Use refs to track previous state and avoid unnecessary updates\nconst previousHealthRef=useRef({});const fallbackIntervalRef=useRef(null);const lastLogTime=useRef(0);const hasReceivedWebSocketUpdate=useRef(false);const lastErrorTime=useRef({});// New ref for error logging circuit breaker\n// Compute overall system health\nconst systemHealth=useMemo(()=>{const statuses=Object.values(health);if(statuses.includes('error')||statuses.includes('stopped')){return'error';}if(statuses.includes('unhealthy')||statuses.includes('degraded')||statuses.includes('disconnected')){return'unhealthy';}if(statuses.every(status=>status==='healthy'||status==='running'||status==='connected'||status==='active')){return'healthy';}return'unknown';},[health]);// Smart logging - only log significant changes\nconst shouldLog=useCallback(function(message){let isHealthy=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const now=Date.now();const tenMinutes=10*60*1000;// Increased from 5 to 10 minutes\nif(!isHealthy){return true;// Always log problems\n}if(now-lastLogTime.current>tenMinutes){lastLogTime.current=now;return true;}return false;},[]);// Get health summary\nconst getHealthSummary=useCallback(()=>{const services=Object.values(health);const healthyServices=services.filter(status=>status==='healthy'||status==='running'||status==='connected'||status==='active').length;return{services:services.length,healthy:healthyServices,unhealthy:services.length-healthyServices,uptime:uptime||0};},[health,uptime]);// Get service status with details\nconst getServiceStatus=useCallback(serviceName=>{const status=health[serviceName]||'unknown';const details=serviceDetails[serviceName]||{};return{status,lastChecked:details.lastChecked||(lastCheck?lastCheck.toLocaleTimeString():'Never'),responseTime:details.responseTime,error:details.error,details};},[health,serviceDetails,lastCheck]);// Format uptime in readable format\nconst formatUptime=useCallback(uptimeMs=>{if(!uptimeMs||uptimeMs<0)return'Unknown';const seconds=Math.floor(uptimeMs/1000);const minutes=Math.floor(seconds/60);const hours=Math.floor(minutes/60);const days=Math.floor(hours/24);if(days>0){return`${days}d ${hours%24}h ${minutes%60}m`;}else if(hours>0){return`${hours}h ${minutes%60}m`;}else if(minutes>0){return`${minutes}m ${seconds%60}s`;}else{return`${seconds}s`;}},[]);// Process health status (from WebSocket or API)\nconst processHealthStatus=useCallback(healthData=>{var _healthData$services,_healthData$services$,_healthData$services2,_healthData$services3,_healthData$services4,_healthData$services5,_healthData$services6,_healthData$services7;if(!healthData)return;const newHealth={backend:((_healthData$services=healthData.services)===null||_healthData$services===void 0?void 0:(_healthData$services$=_healthData$services.backend)===null||_healthData$services$===void 0?void 0:_healthData$services$.status)||'unknown',database:((_healthData$services2=healthData.services)===null||_healthData$services2===void 0?void 0:(_healthData$services3=_healthData$services2.database)===null||_healthData$services3===void 0?void 0:_healthData$services3.status)||'unknown',websocket:((_healthData$services4=healthData.services)===null||_healthData$services4===void 0?void 0:(_healthData$services5=_healthData$services4.websocket)===null||_healthData$services5===void 0?void 0:_healthData$services5.status)||'unknown',honeypotManager:((_healthData$services6=healthData.services)===null||_healthData$services6===void 0?void 0:(_healthData$services7=_healthData$services6.honeypotManager)===null||_healthData$services7===void 0?void 0:_healthData$services7.status)||'unknown'};// Only update if something actually changed\nconst hasChanges=Object.keys(newHealth).some(service=>previousHealthRef.current[service]!==newHealth[service]);if(hasChanges||!previousHealthRef.current.backend){var _healthData$metrics,_healthData$services8,_healthData$services9,_healthData$metrics2,_healthData$services0,_healthData$services1,_healthData$services10,_healthData$services11;previousHealthRef.current={...newHealth};setHealth(newHealth);setLastCheck(new Date());setError(null);// Smart logging - only log real changes\nconst unhealthyServices=Object.entries(newHealth).filter(_ref=>{let[_,status]=_ref;return status==='unhealthy'||status==='error'||status==='stopped';}).map(_ref2=>{let[service,_]=_ref2;return service;});if(unhealthyServices.length>0){if(shouldLog('Service issues',false)){console.warn('ðŸš¨ Service issues:',unhealthyServices);}}else{// Removed frequent \"System healthy\" console.log to reduce spam\n// Only log when there are actual changes, not every health update\nif(hasChanges&&shouldLog('System healthy',true)){console.log('âœ… System status updated');}}// Store response data efficiently\nif(healthData.uptime){setUptime(healthData.uptime*1000);}setMetrics({totalEvents:((_healthData$metrics=healthData.metrics)===null||_healthData$metrics===void 0?void 0:_healthData$metrics.totalEvents)||0,activeConnections:((_healthData$services8=healthData.services)===null||_healthData$services8===void 0?void 0:(_healthData$services9=_healthData$services8.websocket)===null||_healthData$services9===void 0?void 0:_healthData$services9.connections)||0,errorRate:((_healthData$metrics2=healthData.metrics)===null||_healthData$metrics2===void 0?void 0:_healthData$metrics2.errorRate)||0,honeypots:healthData.honeypots||[]});setServiceDetails({backend:((_healthData$services0=healthData.services)===null||_healthData$services0===void 0?void 0:_healthData$services0.backend)||{},database:((_healthData$services1=healthData.services)===null||_healthData$services1===void 0?void 0:_healthData$services1.database)||{},websocket:((_healthData$services10=healthData.services)===null||_healthData$services10===void 0?void 0:_healthData$services10.websocket)||{},honeypotManager:((_healthData$services11=healthData.services)===null||_healthData$services11===void 0?void 0:_healthData$services11.honeypotManager)||{}});}},[shouldLog]);// WebSocket health status updates\nuseEffect(()=>{if(healthStatus){hasReceivedWebSocketUpdate.current=true;processHealthStatus(healthStatus);}},[healthStatus,processHealthStatus]);// Fallback API health check (only when needed)\nconst performFallbackHealthCheck=useCallback(async()=>{try{const response=await checkQuickHealth();processHealthStatus(response);return response;}catch(err){// Only log errors if we haven't seen this error recently\nconst now=Date.now();const errorKey=err.message||'Unknown error';if(!lastErrorTime.current[errorKey]||now-lastErrorTime.current[errorKey]>60000){// Only log same error once per minute\nconsole.error('âŒ Fallback health check failed:',err.message);lastErrorTime.current[errorKey]=now;}setError(err.message||'Health check failed');if(!error){setHealth(prev=>({...prev,backend:'error'}));}return null;}},[error,processHealthStatus]);// Start monitoring\nconst startMonitoring=useCallback(()=>{if(isMonitoring)return;setIsMonitoring(true);// Subscribe to WebSocket health updates\nif(isConnected){subscribeToHealth();}// Initial health check\nperformFallbackHealthCheck();// Setup fallback polling (much less frequent)\nconst scheduleNextFallbackCheck=()=>{if(fallbackIntervalRef.current){clearTimeout(fallbackIntervalRef.current);}// Only use fallback if no WebSocket updates received recently\nconst interval=hasReceivedWebSocketUpdate.current?15*60*1000// 15 minutes when WebSocket working\n:5*60*1000;// 5 minutes when WebSocket not working\nfallbackIntervalRef.current=setTimeout(()=>{// Reset WebSocket flag and check if we need fallback\nhasReceivedWebSocketUpdate.current=false;performFallbackHealthCheck().then(()=>{if(isMonitoring){scheduleNextFallbackCheck();}});},interval);};scheduleNextFallbackCheck();},[isMonitoring,isConnected,subscribeToHealth,performFallbackHealthCheck]);// Stop monitoring\nconst stopMonitoring=useCallback(()=>{if(fallbackIntervalRef.current){clearTimeout(fallbackIntervalRef.current);fallbackIntervalRef.current=null;}unsubscribeFromHealth();setIsMonitoring(false);},[unsubscribeFromHealth]);// Auto-start monitoring\nuseEffect(()=>{if(autoStart){startMonitoring();}return()=>{stopMonitoring();};},[autoStart,startMonitoring,stopMonitoring]);// Subscribe to WebSocket when connected\nuseEffect(()=>{if(isConnected&&isMonitoring){subscribeToHealth();}},[isConnected,isMonitoring]);// Removed subscribeToHealth dependency that was causing infinite loop\n// Cleanup on unmount\nuseEffect(()=>{return()=>{if(fallbackIntervalRef.current){clearTimeout(fallbackIntervalRef.current);}};},[]);return{health,systemHealth,isMonitoring,lastCheck,error,uptime,metrics,serviceDetails,isConnected:isConnected,getHealthSummary,getServiceStatus,formatUptime,startMonitoring,stopMonitoring,performHealthCheck:performFallbackHealthCheck// Keep for manual refresh\n};};export default useHealthMonitoring;","map":{"version":3,"names":["useEffect","useState","useCallback","useRef","useMemo","checkQuickHealth","useWebSocket","useHealthMonitoring","options","arguments","length","undefined","enableNotifications","autoStart","health","setHealth","backend","database","websocket","honeypotManager","isMonitoring","setIsMonitoring","lastCheck","setLastCheck","error","setError","uptime","setUptime","metrics","setMetrics","totalEvents","activeConnections","errorRate","honeypots","serviceDetails","setServiceDetails","isConnected","healthStatus","subscribeToHealth","unsubscribeFromHealth","previousHealthRef","fallbackIntervalRef","lastLogTime","hasReceivedWebSocketUpdate","lastErrorTime","systemHealth","statuses","Object","values","includes","every","status","shouldLog","message","isHealthy","now","Date","tenMinutes","current","getHealthSummary","services","healthyServices","filter","healthy","unhealthy","getServiceStatus","serviceName","details","lastChecked","toLocaleTimeString","responseTime","formatUptime","uptimeMs","seconds","Math","floor","minutes","hours","days","processHealthStatus","healthData","_healthData$services","_healthData$services$","_healthData$services2","_healthData$services3","_healthData$services4","_healthData$services5","_healthData$services6","_healthData$services7","newHealth","hasChanges","keys","some","service","_healthData$metrics","_healthData$services8","_healthData$services9","_healthData$metrics2","_healthData$services0","_healthData$services1","_healthData$services10","_healthData$services11","unhealthyServices","entries","_ref","_","map","_ref2","console","warn","log","connections","performFallbackHealthCheck","response","err","errorKey","prev","startMonitoring","scheduleNextFallbackCheck","clearTimeout","interval","setTimeout","then","stopMonitoring","performHealthCheck"],"sources":["/home/demon/distributed-architecture/central-infrastructure/frontend/src/hooks/useHealthMonitoring.js"],"sourcesContent":["import { useEffect, useState, useCallback, useRef, useMemo } from 'react';\nimport { checkQuickHealth } from '../api';\nimport useWebSocket from './useWebSocket';\n\nconst useHealthMonitoring = (options = {}) => {\n  const { \n    enableNotifications = true,\n    autoStart = true\n  } = options;\n\n  const [health, setHealth] = useState({\n    backend: 'unknown',\n    database: 'unknown',\n    websocket: 'unknown',\n    honeypotManager: 'unknown'\n  });\n\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [lastCheck, setLastCheck] = useState(null);\n  const [error, setError] = useState(null);\n  const [uptime, setUptime] = useState(null);\n  const [metrics, setMetrics] = useState({\n    totalEvents: 0,\n    activeConnections: 0,\n    errorRate: 0,\n    honeypots: []\n  });\n  const [serviceDetails, setServiceDetails] = useState({});\n  \n  // Use WebSocket for real-time health updates\n  const { \n    isConnected, \n    healthStatus, \n    subscribeToHealth, \n    unsubscribeFromHealth \n  } = useWebSocket();\n  \n  // Use refs to track previous state and avoid unnecessary updates\n  const previousHealthRef = useRef({});\n  const fallbackIntervalRef = useRef(null);\n  const lastLogTime = useRef(0);\n  const hasReceivedWebSocketUpdate = useRef(false);\n  const lastErrorTime = useRef({}); // New ref for error logging circuit breaker\n\n  // Compute overall system health\n  const systemHealth = useMemo(() => {\n    const statuses = Object.values(health);\n    if (statuses.includes('error') || statuses.includes('stopped')) {\n      return 'error';\n    }\n    if (statuses.includes('unhealthy') || statuses.includes('degraded') || statuses.includes('disconnected')) {\n      return 'unhealthy';\n    }\n    if (statuses.every(status => status === 'healthy' || status === 'running' || status === 'connected' || status === 'active')) {\n      return 'healthy';\n    }\n    return 'unknown';\n  }, [health]);\n\n  // Smart logging - only log significant changes\n  const shouldLog = useCallback((message, isHealthy = true) => {\n    const now = Date.now();\n    const tenMinutes = 10 * 60 * 1000; // Increased from 5 to 10 minutes\n    \n    if (!isHealthy) {\n      return true; // Always log problems\n    }\n    \n    if (now - lastLogTime.current > tenMinutes) {\n      lastLogTime.current = now;\n      return true;\n    }\n    \n    return false;\n  }, []);\n\n  // Get health summary\n  const getHealthSummary = useCallback(() => {\n    const services = Object.values(health);\n    const healthyServices = services.filter(status => \n      status === 'healthy' || status === 'running' || status === 'connected' || status === 'active'\n    ).length;\n    \n    return {\n      services: services.length,\n      healthy: healthyServices,\n      unhealthy: services.length - healthyServices,\n      uptime: uptime || 0\n    };\n  }, [health, uptime]);\n\n  // Get service status with details\n  const getServiceStatus = useCallback((serviceName) => {\n    const status = health[serviceName] || 'unknown';\n    const details = serviceDetails[serviceName] || {};\n    \n    return {\n      status,\n      lastChecked: details.lastChecked || (lastCheck ? lastCheck.toLocaleTimeString() : 'Never'),\n      responseTime: details.responseTime,\n      error: details.error,\n      details\n    };\n  }, [health, serviceDetails, lastCheck]);\n\n  // Format uptime in readable format\n  const formatUptime = useCallback((uptimeMs) => {\n    if (!uptimeMs || uptimeMs < 0) return 'Unknown';\n    \n    const seconds = Math.floor(uptimeMs / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) {\n      return `${days}d ${hours % 24}h ${minutes % 60}m`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }, []);\n\n  // Process health status (from WebSocket or API)\n  const processHealthStatus = useCallback((healthData) => {\n    if (!healthData) return;\n\n    const newHealth = {\n      backend: healthData.services?.backend?.status || 'unknown',\n      database: healthData.services?.database?.status || 'unknown',\n      websocket: healthData.services?.websocket?.status || 'unknown',\n      honeypotManager: healthData.services?.honeypotManager?.status || 'unknown'\n    };\n\n    // Only update if something actually changed\n    const hasChanges = Object.keys(newHealth).some(\n      service => previousHealthRef.current[service] !== newHealth[service]\n    );\n\n    if (hasChanges || !previousHealthRef.current.backend) {\n      previousHealthRef.current = { ...newHealth };\n      setHealth(newHealth);\n      setLastCheck(new Date());\n      setError(null);\n\n      // Smart logging - only log real changes\n      const unhealthyServices = Object.entries(newHealth)\n        .filter(([_, status]) => status === 'unhealthy' || status === 'error' || status === 'stopped')\n        .map(([service, _]) => service);\n\n      if (unhealthyServices.length > 0) {\n        if (shouldLog('Service issues', false)) {\n          console.warn('ðŸš¨ Service issues:', unhealthyServices);\n        }\n      } else {\n        // Removed frequent \"System healthy\" console.log to reduce spam\n        // Only log when there are actual changes, not every health update\n        if (hasChanges && shouldLog('System healthy', true)) {\n          console.log('âœ… System status updated');\n        }\n      }\n\n      // Store response data efficiently\n      if (healthData.uptime) {\n        setUptime(healthData.uptime * 1000);\n      }\n\n      setMetrics({\n        totalEvents: healthData.metrics?.totalEvents || 0,\n        activeConnections: healthData.services?.websocket?.connections || 0,\n        errorRate: healthData.metrics?.errorRate || 0,\n        honeypots: healthData.honeypots || []\n      });\n\n      setServiceDetails({\n        backend: healthData.services?.backend || {},\n        database: healthData.services?.database || {},\n        websocket: healthData.services?.websocket || {},\n        honeypotManager: healthData.services?.honeypotManager || {}\n      });\n    }\n  }, [shouldLog]);\n\n  // WebSocket health status updates\n  useEffect(() => {\n    if (healthStatus) {\n      hasReceivedWebSocketUpdate.current = true;\n      processHealthStatus(healthStatus);\n    }\n  }, [healthStatus, processHealthStatus]);\n\n  // Fallback API health check (only when needed)\n  const performFallbackHealthCheck = useCallback(async () => {\n    try {\n      const response = await checkQuickHealth();\n      processHealthStatus(response);\n      return response;\n    } catch (err) {\n      // Only log errors if we haven't seen this error recently\n      const now = Date.now();\n      const errorKey = err.message || 'Unknown error';\n      \n      if (!lastErrorTime.current[errorKey] || \n          (now - lastErrorTime.current[errorKey]) > 60000) { // Only log same error once per minute\n        console.error('âŒ Fallback health check failed:', err.message);\n        lastErrorTime.current[errorKey] = now;\n      }\n      \n      setError(err.message || 'Health check failed');\n      \n      if (!error) {\n        setHealth(prev => ({\n          ...prev,\n          backend: 'error'\n        }));\n      }\n      \n      return null;\n    }\n  }, [error, processHealthStatus]);\n\n  // Start monitoring\n  const startMonitoring = useCallback(() => {\n    if (isMonitoring) return;\n    \n    setIsMonitoring(true);\n    \n    // Subscribe to WebSocket health updates\n    if (isConnected) {\n      subscribeToHealth();\n    }\n    \n    // Initial health check\n    performFallbackHealthCheck();\n    \n    // Setup fallback polling (much less frequent)\n    const scheduleNextFallbackCheck = () => {\n      if (fallbackIntervalRef.current) {\n        clearTimeout(fallbackIntervalRef.current);\n      }\n      \n      // Only use fallback if no WebSocket updates received recently\n      const interval = hasReceivedWebSocketUpdate.current \n        ? 15 * 60 * 1000  // 15 minutes when WebSocket working\n        : 5 * 60 * 1000;  // 5 minutes when WebSocket not working\n      \n      fallbackIntervalRef.current = setTimeout(() => {\n        // Reset WebSocket flag and check if we need fallback\n        hasReceivedWebSocketUpdate.current = false;\n        \n        performFallbackHealthCheck().then(() => {\n          if (isMonitoring) {\n            scheduleNextFallbackCheck();\n          }\n        });\n      }, interval);\n    };\n    \n    scheduleNextFallbackCheck();\n  }, [isMonitoring, isConnected, subscribeToHealth, performFallbackHealthCheck]);\n\n  // Stop monitoring\n  const stopMonitoring = useCallback(() => {\n    if (fallbackIntervalRef.current) {\n      clearTimeout(fallbackIntervalRef.current);\n      fallbackIntervalRef.current = null;\n    }\n    \n    unsubscribeFromHealth();\n    setIsMonitoring(false);\n  }, [unsubscribeFromHealth]);\n\n  // Auto-start monitoring\n  useEffect(() => {\n    if (autoStart) {\n      startMonitoring();\n    }\n    \n    return () => {\n      stopMonitoring();\n    };\n  }, [autoStart, startMonitoring, stopMonitoring]);\n\n  // Subscribe to WebSocket when connected\n  useEffect(() => {\n    if (isConnected && isMonitoring) {\n      subscribeToHealth();\n    }\n  }, [isConnected, isMonitoring]); // Removed subscribeToHealth dependency that was causing infinite loop\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (fallbackIntervalRef.current) {\n        clearTimeout(fallbackIntervalRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    health,\n    systemHealth,\n    isMonitoring,\n    lastCheck,\n    error,\n    uptime,\n    metrics,\n    serviceDetails,\n    isConnected: isConnected,\n    getHealthSummary,\n    getServiceStatus,\n    formatUptime,\n    startMonitoring,\n    stopMonitoring,\n    performHealthCheck: performFallbackHealthCheck // Keep for manual refresh\n  };\n};\n\nexport default useHealthMonitoring; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}